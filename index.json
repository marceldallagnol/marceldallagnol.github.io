[{"authors":["admin"],"categories":null,"content":"I am a second-year PhD student in theoretical computer science at the University of Warwick, under the supervision of Tom Gur.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"http://marceldallagnol.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a second-year PhD student in theoretical computer science at the University of Warwick, under the supervision of Tom Gur.","tags":null,"title":"Marcel Dall'Agnol","type":"authors"},{"authors":null,"categories":null,"content":"","date":1607945400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607945400,"objectID":"4c456dd324a6ec9f1ae2428f50e97da2","permalink":"http://marceldallagnol.github.io/talk/qmap-wpccs/","publishdate":"2020-12-10T00:00:00Z","relpermalink":"/talk/qmap-wpccs/","section":"talk","summary":"With the prevalence of massive datasets and small computing devices, offloading computation becomes increasingly important. One may model this problem as follows: a weak device (the \"verifier\") holds an input string and communicates with an all-powerful computer (the \"prover\") so as to verify the validity of this string. Since the verifier cannot perform the verification on its own, the prover provides a digest of the computational task, allowing the verifier to check that it was performed correctly. In an extreme setting, the verifier cannot even read all of its input, and must decide whether it is valid or far from any valid string; in this case, the digest is called a proof of proximity. We formalise quantum proofs of proximity, where prover and verifier are quantum computers, and begin to chart the complexity landscape of the quantum/classical as well as the interactive/non-interactive variants of these proof systems. This is joint work with Tom Gur and Subhayan Roy Moulik.","tags":[],"title":"Quantum proofs of proximity","type":"talk"},{"authors":null,"categories":null,"content":"","date":1595260200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595260200,"objectID":"b0cd3750a4671e28557abb12183a94ab","permalink":"http://marceldallagnol.github.io/talk/daisies-wola/","publishdate":"2020-07-20T16:50:00+01:00","relpermalink":"/talk/daisies-wola/","section":"talk","summary":"Motivated by the applicability of relaxed sunflower techniques to property testing and local decoding, we define a common framework that captures a wide family of local algorithms, encompassing those as well as proofs of proximity. This enables us to show that the structure of every algorithm that makes a constant number of adaptive queries and satisfies a natural robustness condition admits a sample-based algorithm with sublinear sample complexity; moreover, this transformation is nearly optimal.\n\nThe talk will give an overview of the general framework and the transformation from adaptive to sample-based algorithms, which relies heavily on relaxed sunflower lemmas and the Hajnal-Szemerédi theorem. Applying this transformation to particular cases, we obtain: (1) a strengthening of the state-of-the-art lower bound for relaxed locally decodable codes that improves the dependency in query complexity exponentially; (2) a transformation of any constant-query tester into a sample-based tester with sublinear sample complexity, that was previously known to hold only for non-adaptive testers; and (3) a limit on the power of sublinear-time delegation of computation, by showing almost tightness of the known separation between testers and proofs of proximity.\n\nJoint work with Tom Gur and Oded Lachish.","tags":[],"title":"A structural theorem for local algorithms with applications to coding, testing and delegation","type":"talk"},{"authors":["Tom Gur","Oded Lachish"],"categories":null,"content":"","date":1594767600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594767600,"objectID":"937dffa8c752f83a074af67ad4dfecf7","permalink":"http://marceldallagnol.github.io/publication/daisy2/","publishdate":"2020-07-15T00:00:00+01:00","relpermalink":"/publication/daisy2/","section":"publication","summary":"We prove a general structural theorem for a wide family of local algorithms, which includes property testers, local decoders, and PCPs of proximity. Namely, we show that the structure of every algorithm that makes $q$ adaptive queries and satisfies a natural robustness condition admits a sample-based algorithm with $n^{1- 1/O(q^2 \\log^2 q)}$ sample complexity, following the definition of Goldreich and Ron (TOCT 2016). We prove that this transformation is nearly optimal. Our theorem also admits a scheme for constructing privacy-preserving local algorithms.\n\nUsing the unified view that our structural theorem provides, we obtain results regarding various types of local algorithms, including the following.\n\n* We strengthen the state-of-the-art lower bound for relaxed locally decodable codes, obtaining an _exponential_ improvement on the dependency in query complexity; this resolves an open problem raised by Gur and Lachish (SODA 2020).\n\n* We show that any (constant-query) testable property admits a sample-based tester with sublinear sample complexity; this resolves a problem left open in a work of Fischer, Lachish, and Vasudev (FOCS 2015) by extending their main result to adaptive testers.\n\n* We prove that the known separation between proofs of proximity and testers is essentially maximal; this resolves a problem left open by Gur and Rothblum (ECCC 2013, Computational Complexity 2018) regarding sublinear-time delegation of computation.\n\nOur techniques strongly rely on relaxed sunflower lemmas and the Hajnal–Szemerédi theorem.","tags":[],"title":"A Structural Theorem for Local Algorithms with Applications to Coding, Testing, and Privacy","type":"publication"},{"authors":null,"categories":null,"content":"","date":1525388400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1525388400,"objectID":"e6f2e7442e01c49fb1e250b9653482f9","permalink":"http://marceldallagnol.github.io/talk/cryptorave/","publishdate":"2018-05-04T00:00:00+01:00","relpermalink":"/talk/cryptorave/","section":"talk","summary":"A matemática por trás da criptografia é, além de muito bonita, cheia de resultados surpreendentes. Logo de cara, descobrimos que cripto perfeita não existe. Tentando achar uma saída, encontramos problemas que o Universo trabalhando desde o big bang não daria conta de resolver. Além disso, veremos que ninguém sabe se a cripto que usamos todos os dias é segura de verdade (por sorte, ninguém mostrou que não é). Por fim, exploramos o que a computação quântica muda nisso tudo. \n\nNesta palestra, que ninguém precisa ser matemáticx para assistir, exploramos a história da criptografia desde muito antes dos computadores até o futuro da computação quântica.\n\nO que é necessário para construir cripto? Se é tão antiga, por que essa ciência hoje tem tanto a ver com computação? Podemos nos sentir seguros com nossos laptops e celulares contra o aparato da NSA? (se sim, até quando?)\n\nPrimeiro, estabelecemos os componentes básicos para um algoritmo criptográfico (seja no computador ou com papel e caneta). Em seguida, vemos alguns exemplos: a cifra de César e as de substituição.\n\nComo cripto depende de operações \"difíceis de desfazer\", buscamos uma definição de dificuldade que se possa medir. Descobrimos, aí, o motivo para os computadores serem tão importantes, exploramos o algoritmo One-Time Pad e o conceito de complexidade algorítmica.\n\nEntão vemos como funcionam dois dos algoritmos mais importantes e usados hoje em dia: Diffie-Hellman e RSA. Por fim, vemos com cuidado o que a computação quântica traz de novo: como ela pode ser usada para fortalecer nossa segurança, quais algoritmos ela quebra (e quais não), e se ela é tudo isso que dizem por aí.","tags":[],"title":"The mathematical beauty of cryptography (in Portuguese)","type":"talk"},{"authors":["Emily Grenader","Troels E. Hansen","Fernando da Silva Nos","Danilo Gasques Rodrigues","Nadir Weibel"],"categories":null,"content":"","date":1367017200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1367017200,"objectID":"b0f634e14fc7fdcdb759bce94b4efbdb","permalink":"http://marceldallagnol.github.io/publication/motiondraw/","publishdate":"2013-04-27T00:00:00+01:00","relpermalink":"/publication/motiondraw/","section":"publication","summary":"Contemporary staged performances frequently utilize advanced lighting and projection techniques. The design and creation of these stage effects are rarely accessible to actual performers and must be designed by professional lighting designers or highly-paid programmers. With MotionDraw we want to create an affordable system that is easily controlled and manipulated by performers. With intuitive gestures, non-specialized users can control the MotionDraw visual library and interact with the captured visual record of their own movements. Possible uses of our system grew out of research with dancers and performers, and the current technical implementation sets a framework for including additional visual libraries and capabilities.","tags":[],"title":"MotionDraw: a Tool for Enhancing Art and Performance Using Kinect","type":"publication"}]